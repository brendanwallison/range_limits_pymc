#!/usr/bin/env python3
"""
Reconstruct r_array, K_array, and densities from saved NumPyro MAP parameters.

Assumptions
-----------
- params contains ONLY sampled random variables (MAP or posterior draw)
- data matches exactly the data dict used during model fitting
- No deterministic nodes were saved during inference

Outputs
-------
- r_array      : (time, Ny, Nx)
- K_array      : (time, Ny, Nx)
- densities    : (time, Ny, Nx)
"""

import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
import jax
import jax.numpy as jnp
import jax.nn as jnn

from numpyro.contrib.hsgp.approximation import linear_approximation
from numpyro.contrib.hsgp.spectral_densities import (
    diag_spectral_density_squared_exponential
)
import numpy as np
from src.ingest_directional import build_data_jax

import matplotlib.pyplot as plt


import os
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter

from src.model import precompute_s_Q_vectorized
from src.model import forward_sim_2d

import pickle

from numpyro.optim import Adam
from src.model import build_model_2d
from src.ingest_directional import build_data_jax
from numpyro.infer.autoguide import AutoDelta
from numpyro.infer.util import constrain_fn
from numpyro import handlers

def load_checkpoint_params(ckpt_path, data):
    """
    Load SVI checkpoint and reconstruct constrained MAP parameters
    using constrain_fn, passing required model arguments.
    """
    with open(ckpt_path, "rb") as f:
        ckpt = pickle.load(f)

    svi_state = ckpt["svi_state"]
    optimizer = Adam(ckpt["config"]["lr"])
    model = build_model_2d
    seeded_model = handlers.seed(model, ckpt["rng_key"])

    # Extract unconstrained parameters from optimizer state
    params_auto = optimizer.get_params(svi_state.optim_state)
    params_clean = {k.replace("_auto_loc",""): v for k,v in params_auto.items()}

    # Constrain parameters using the model and required data argument
    params_constrained = constrain_fn(
        seeded_model,
        (data,),      # tuple of positional args
        {},           # model_kwargs
        params=params_clean
    )

    return params_constrained


def load_map_params(map_path):
    """Load a plain .npz map estimate (flat mapping name->array)."""
    with np.load(map_path) as z:
        return {k: jnp.asarray(v) for k, v in z.items()}

# -----------------------------
# Helper functions
# -----------------------------

FJ = 0.5  # juvenile fraction (fixed as requested)


def _compute_r_eff(r, Q):
    """
    Compute effective growth rate:
      r_eff = r + log(1 - fJ + fJ * Q)
    """
    return r + np.log(1.0 - FJ + FJ * Q + 1e-12)


def _plot_r_eff_timestep(r, s, Qt, direction_keys, t, out_path, dpi=150):
    """
    Plot 2x3 layout:
      Row 1: r_eff(no-disp=S) | r_eff(N) | r_eff(S)
      Row 2: r_eff(E)         | r_eff(W) | r_eff(mean)
    """
    fig, axes = plt.subplots(2, 3, figsize=(18, 10), constrained_layout=True)

    # No-dispersal (degenerate path)
    r_eff_nodisp = _compute_r_eff(r, s)
    im = axes[0, 0].imshow(r_eff_nodisp)
    axes[0, 0].set_title(f"r_eff no-disp t={t}")
    plt.colorbar(im, ax=axes[0, 0], fraction=0.046)

    r_eff_dirs = []

    for idx, (ax, key) in enumerate(
        zip([axes[0,1], axes[0,2], axes[1,0], axes[1,1]], direction_keys)
    ):
        r_eff_d = _compute_r_eff(r, Qt[idx])
        r_eff_dirs.append(r_eff_d)
        im = ax.imshow(r_eff_d)
        ax.set_title(f"r_eff {key} t={t}")
        plt.colorbar(im, ax=ax, fraction=0.046)

    # Directional mean
    r_eff_mean = np.mean(r_eff_dirs, axis=0)
    im = axes[1, 2].imshow(r_eff_mean)
    axes[1, 2].set_title(f"r_eff mean t={t}")
    plt.colorbar(im, ax=axes[1, 2], fraction=0.046)

    for ax in axes.flat:
        ax.set_xticks([])
        ax.set_yticks([])

    fig.savefig(out_path, dpi=dpi)
    plt.close(fig)


def _plot_r_eff_timeavg(r_avg, s_avg, Q_avg, direction_keys, out_path, dpi=150):
    """
    Time-averaged r_eff visualization with same layout as timestep version.
    """
    fig, axes = plt.subplots(2, 3, figsize=(18, 10), constrained_layout=True)

    r_eff_nodisp = _compute_r_eff(r_avg, s_avg)
    im = axes[0, 0].imshow(r_eff_nodisp)
    axes[0, 0].set_title("r_eff no-disp time-avg")
    plt.colorbar(im, ax=axes[0, 0], fraction=0.046)

    r_eff_dirs = []

    for idx, (ax, key) in enumerate(
        zip([axes[0,1], axes[0,2], axes[1,0], axes[1,1]], direction_keys)
    ):
        r_eff_d = _compute_r_eff(r_avg, Q_avg[idx])
        r_eff_dirs.append(r_eff_d)
        im = ax.imshow(r_eff_d)
        ax.set_title(f"r_eff {key} time-avg")
        plt.colorbar(im, ax=ax, fraction=0.046)

    r_eff_mean = np.mean(r_eff_dirs, axis=0)
    im = axes[1, 2].imshow(r_eff_mean)
    axes[1, 2].set_title("r_eff mean time-avg")
    plt.colorbar(im, ax=axes[1, 2], fraction=0.046)

    for ax in axes.flat:
        ax.set_xticks([])
        ax.set_yticks([])

    fig.savefig(out_path, dpi=dpi)
    plt.close(fig)

def _plot_timeavg_r_eff_masks(r_avg, s_avg, Q_avg, direction_keys, out_path, dpi=150):
    fig, axes = plt.subplots(2, 3, figsize=(18, 10), constrained_layout=True)

    r_eff_dirs = [_compute_r_eff(r_avg, Q_avg[i]) for i in range(4)]
    r_eff_mean = _compute_r_eff(r_avg, Q_avg.mean(axis=0))
    r_eff_nodisp = _compute_r_eff(r_avg, s_avg)

    masks = [
        (axes[0, 0], r_eff_dirs[0] > 0, f"source {direction_keys[0]} avg"),
        (axes[0, 1], r_eff_dirs[1] > 0, f"source {direction_keys[1]} avg"),
        (axes[0, 2], r_eff_mean > 0, "source mean Q avg"),
        (axes[1, 0], r_eff_dirs[2] > 0, f"source {direction_keys[2]} avg"),
        (axes[1, 1], r_eff_dirs[3] > 0, f"source {direction_keys[3]} avg"),
        (axes[1, 2], r_eff_nodisp > 0, "source no dispersal avg"),
    ]

    for ax, mask, title in masks:
        im = ax.imshow(mask.astype(float), vmin=0, vmax=1)
        ax.set_title(title)
        plt.colorbar(im, ax=ax, fraction=0.046, ticks=[0, 1])
        ax.set_xticks([])
        ax.set_yticks([])

    fig.savefig(out_path, dpi=dpi)
    plt.close(fig)


def _plot_r_eff_diff_timestep(r, s, Qt, direction_keys, t, out_path, dpi=150):
    """
    2x3 layout of Δr_eff = r_eff(directional) - r_eff(no dispersal)
      Row 1: N | S | mean Q
      Row 2: E | W | zero baseline
    """
    fig, axes = plt.subplots(2, 3, figsize=(18, 10), constrained_layout=True)

    r_eff_nodisp = _compute_r_eff(r, s)
    r_eff_dirs = [_compute_r_eff(r, Qt[i]) for i in range(4)]
    r_eff_mean = _compute_r_eff(r, Qt.mean(axis=0))

    diffs = [
        (axes[0, 0], r_eff_dirs[0] - r_eff_nodisp, f"Δr_eff {direction_keys[0]}"),
        (axes[0, 1], r_eff_dirs[1] - r_eff_nodisp, f"Δr_eff {direction_keys[1]}"),
        (axes[0, 2], r_eff_mean - r_eff_nodisp, "Δr_eff mean Q"),
        (axes[1, 0], r_eff_dirs[2] - r_eff_nodisp, f"Δr_eff {direction_keys[2]}"),
        (axes[1, 1], r_eff_dirs[3] - r_eff_nodisp, f"Δr_eff {direction_keys[3]}"),
        (axes[1, 2], np.zeros_like(r), "no dispersal baseline"),
    ]

    for ax, field, title in diffs:
        im = ax.imshow(field)
        ax.set_title(title)
        plt.colorbar(im, ax=ax, fraction=0.046)
        ax.set_xticks([])
        ax.set_yticks([])

    fig.savefig(out_path, dpi=dpi)
    plt.close(fig)


def _plot_r_eff_masks_timestep(r, s, Qt, direction_keys, t, out_path, dpi=150):
    """
    2x3 binary source–sink masks:
      Row 1: N | S | mean Q
      Row 2: E | W | no dispersal
    """
    fig, axes = plt.subplots(2, 3, figsize=(18, 10), constrained_layout=True)

    r_eff_dirs = [_compute_r_eff(r, Qt[i]) for i in range(4)]
    r_eff_mean = _compute_r_eff(r, Qt.mean(axis=0))
    r_eff_nodisp = _compute_r_eff(r, s)

    masks = [
        (axes[0, 0], r_eff_dirs[0] > 0, f"source {direction_keys[0]}"),
        (axes[0, 1], r_eff_dirs[1] > 0, f"source {direction_keys[1]}"),
        (axes[0, 2], r_eff_mean > 0, "source mean Q"),
        (axes[1, 0], r_eff_dirs[2] > 0, f"source {direction_keys[2]}"),
        (axes[1, 1], r_eff_dirs[3] > 0, f"source {direction_keys[3]}"),
        (axes[1, 2], r_eff_nodisp > 0, "source no dispersal"),
    ]

    for ax, mask, title in masks:
        im = ax.imshow(mask.astype(float), vmin=0, vmax=1)
        ax.set_title(title)
        plt.colorbar(im, ax=ax, fraction=0.046, ticks=[0, 1])
        ax.set_xticks([])
        ax.set_yticks([])

    fig.savefig(out_path, dpi=dpi)
    plt.close(fig)

def _plot_timeavg_r_eff_diff(r_avg, s_avg, Q_avg, direction_keys, out_path, dpi=150):
    fig, axes = plt.subplots(2, 3, figsize=(18, 10), constrained_layout=True)

    r_eff_nodisp = _compute_r_eff(r_avg, s_avg)
    r_eff_dirs = [_compute_r_eff(r_avg, Q_avg[i]) for i in range(4)]
    r_eff_mean = _compute_r_eff(r_avg, Q_avg.mean(axis=0))

    diffs = [
        (axes[0, 0], r_eff_dirs[0] - r_eff_nodisp, f"Δr_eff {direction_keys[0]} avg"),
        (axes[0, 1], r_eff_dirs[1] - r_eff_nodisp, f"Δr_eff {direction_keys[1]} avg"),
        (axes[0, 2], r_eff_mean - r_eff_nodisp, "Δr_eff mean Q avg"),
        (axes[1, 0], r_eff_dirs[2] - r_eff_nodisp, f"Δr_eff {direction_keys[2]} avg"),
        (axes[1, 1], r_eff_dirs[3] - r_eff_nodisp, f"Δr_eff {direction_keys[3]} avg"),
        (axes[1, 2], np.zeros_like(r_avg), "no dispersal baseline"),
    ]

    for ax, field, title in diffs:
        im = ax.imshow(field)
        ax.set_title(title)
        plt.colorbar(im, ax=ax, fraction=0.046)
        ax.set_xticks([])
        ax.set_yticks([])

    fig.savefig(out_path, dpi=dpi)
    plt.close(fig)


def _make_obs_grid_for_t(obs_rows, obs_cols, obs_time_indices, observed_results, t, Ny, Nx, flipud=False, obs_smooth_sigma=None):
    """
    Build observed-only grid for a single timestep t.
    Returns an array shape (Ny, Nx) with NaNs where no observation exists.
    """
    obs_grid = np.full((Ny, Nx), np.nan)
    mask_t = obs_time_indices == t
    if np.any(mask_t):
        rows_t = obs_rows[mask_t]
        cols_t = obs_cols[mask_t]
        vals_t = observed_results[mask_t]
        for i, j in np.unique(np.column_stack([rows_t, cols_t]), axis=0):
            m = (rows_t == i) & (cols_t == j)
            obs_grid[i, j] = vals_t[m].mean()
    if flipud:
        obs_grid = np.flipud(obs_grid)

    if obs_smooth_sigma is not None:
        valid = ~np.isnan(obs_grid)
        filled = np.where(valid, obs_grid, 0.0)
        smoothed = gaussian_filter(filled, sigma=obs_smooth_sigma)
        weight = gaussian_filter(valid.astype(float), sigma=obs_smooth_sigma)
        with np.errstate(invalid="ignore", divide="ignore"):
            obs_grid = np.where(weight > 0, smoothed / weight, np.nan)

    return obs_grid


def _make_obs_grid_timeavg(obs_rows, obs_cols, observed_results, Ny, Nx, flipud=False):
    """
    Build observed grid averaged across all times (mean per cell).
    """
    obs_grid = np.full((Ny, Nx), np.nan)
    if obs_rows.size > 0:
        for i, j in np.unique(np.column_stack([obs_rows, obs_cols]), axis=0):
            mask = (obs_rows == i) & (obs_cols == j)
            if np.any(mask):
                obs_grid[i, j] = observed_results[mask].mean()
    if flipud:
        obs_grid = np.flipud(obs_grid)
    return obs_grid


def _plot_main_timestep(r, K, D, obs_grid, t, out_path, dpi=150):
    """
    Plot the 2x3 layout for a single timestep and save to out_path.
    """
    logD = np.log(D + 1e-12)
    r_binary = (r > 0).astype(float)

    fig, axes = plt.subplots(2, 3, figsize=(18, 10), constrained_layout=True)

    im = axes[0, 0].imshow(r)
    axes[0, 0].set_title(f"r t={t}")
    plt.colorbar(im, ax=axes[0, 0], fraction=0.046)

    im = axes[0, 1].imshow(K)
    axes[0, 1].set_title("K")
    plt.colorbar(im, ax=axes[0, 1], fraction=0.046)

    im = axes[0, 2].imshow(D)
    axes[0, 2].set_title("densities")
    plt.colorbar(im, ax=axes[0, 2], fraction=0.046)

    im = axes[1, 0].imshow(logD)
    axes[1, 0].set_title("log densities")
    plt.colorbar(im, ax=axes[1, 0], fraction=0.046)

    im = axes[1, 1].imshow(r_binary, vmin=0, vmax=1)
    axes[1, 1].set_title("r > 0")
    plt.colorbar(im, ax=axes[1, 1], fraction=0.046, ticks=[0, 1])

    im = axes[1, 2].imshow(obs_grid)
    axes[1, 2].set_title("observed density")
    plt.colorbar(im, ax=axes[1, 2], fraction=0.046)

    for ax in axes.flat:
        ax.set_xticks([])
        ax.set_yticks([])

    fig.savefig(out_path, dpi=dpi)
    plt.close(fig)


def _plot_timeavg_main(r_avg, K_avg, D_avg, obs_grid_avg, out_path, dpi=150):
    """
    Plot the 2x3 time-averaged snapshot and save.
    """
    logD_avg = np.log(D_avg + 1e-12)
    r_binary_avg = (r_avg > 0).astype(float)

    fig, axes = plt.subplots(2, 3, figsize=(18, 10), constrained_layout=True)

    im = axes[0, 0].imshow(r_avg)
    axes[0, 0].set_title("r time-avg")
    plt.colorbar(im, ax=axes[0, 0], fraction=0.046)

    im = axes[0, 1].imshow(K_avg)
    axes[0, 1].set_title("K time-avg")
    plt.colorbar(im, ax=axes[0, 1], fraction=0.046)

    im = axes[0, 2].imshow(D_avg)
    axes[0, 2].set_title("densities time-avg")
    plt.colorbar(im, ax=axes[0, 2], fraction=0.046)

    im = axes[1, 0].imshow(logD_avg)
    axes[1, 0].set_title("log densities time-avg")
    plt.colorbar(im, ax=axes[1, 0], fraction=0.046)

    im = axes[1, 1].imshow(r_binary_avg, vmin=0, vmax=1)
    axes[1, 1].set_title("r > 0 time-avg")
    plt.colorbar(im, ax=axes[1, 1], fraction=0.046, ticks=[0, 1])

    im = axes[1, 2].imshow(obs_grid_avg)
    axes[1, 2].set_title("observed density all times")
    plt.colorbar(im, ax=axes[1, 2], fraction=0.046)

    for ax in axes.flat:
        ax.set_xticks([])
        ax.set_yticks([])

    fig.savefig(out_path, dpi=dpi)
    plt.close(fig)

def _plot_Qs_s_timestep(s, Qt, direction_keys, t, out_path, dpi=150):
    """
    Plot 2x3 layout:
      Row 1: s | Q_N | Q_S
      Row 2: Q_E | Q_W | Q_W - Q_E

    Parameters
    - s: 2D array or None
    - Qt: 3D array shape (4, Ny, Nx) or None, order matches direction_keys
    - direction_keys: list of 4 strings
    - t: timestep index (for titles)
    - out_path: filename to save
    """
    fig, axes = plt.subplots(2, 3, figsize=(18, 10), constrained_layout=True)

    # Panel (0,0): s
    ax = axes[0, 0]
    if s is not None:
        im = ax.imshow(s)
        ax.set_title(f"s t={t}")
        plt.colorbar(im, ax=ax, fraction=0.046)
    else:
        ax.axis("off")
        ax.set_title("s missing")

    # Panels (0,1) and (0,2): Q_N, Q_S
    if Qt is not None:
        # Q_N (index 0)
        im = axes[0, 1].imshow(Qt[0])
        axes[0, 1].set_title(f"Q {direction_keys[0]} t={t}")
        plt.colorbar(im, ax=axes[0, 1], fraction=0.046)

        # Q_S (index 1)
        im = axes[0, 2].imshow(Qt[1])
        axes[0, 2].set_title(f"Q {direction_keys[1]} t={t}")
        plt.colorbar(im, ax=axes[0, 2], fraction=0.046)

        # Q_E (index 2)
        im = axes[1, 0].imshow(Qt[2])
        axes[1, 0].set_title(f"Q {direction_keys[2]} t={t}")
        plt.colorbar(im, ax=axes[1, 0], fraction=0.046)

        # Q_W (index 3)
        im = axes[1, 1].imshow(Qt[3])
        axes[1, 1].set_title(f"Q {direction_keys[3]} t={t}")
        plt.colorbar(im, ax=axes[1, 1], fraction=0.046)

        # Q_W - Q_E
        diff = Qt[3] - Qt[2]
        im = axes[1, 2].imshow(diff)
        axes[1, 2].set_title(f"Q {direction_keys[3]} - Q {direction_keys[2]} t={t}")
        plt.colorbar(im, ax=axes[1, 2], fraction=0.046)
    else:
        # Turn off Q panels if Qt missing
        for ax_idx, key in zip([(0,1),(0,2),(1,0),(1,1),(1,2)], direction_keys + ["W-E"]):
            ax = axes[ax_idx]
            ax.axis("off")
            ax.set_title(f"Q {key} missing")

    # Remove ticks
    for ax in axes.flat:
        ax.set_xticks([])
        ax.set_yticks([])

    fig.savefig(out_path, dpi=dpi)
    plt.close(fig)


def _plot_timeavg_Qs_s(s_avg, Q_avg, direction_keys, out_path, dpi=150):
    """
    Plot 2x3 time-averaged snapshot:
      Row 1: s (time-avg) | Q_N (time-avg) | Q_S (time-avg)
      Row 2: Q_E (time-avg) | Q_W (time-avg) | Q_W - Q_E (time-avg)
    """
    fig, axes = plt.subplots(2, 3, figsize=(18, 10), constrained_layout=True)

    # s time-avg
    ax = axes[0, 0]
    if s_avg is not None:
        im = ax.imshow(s_avg)
        ax.set_title("s time-avg")
        plt.colorbar(im, ax=ax, fraction=0.046)
    else:
        ax.axis("off")
        ax.set_title("s missing")

    if Q_avg is not None:
        # Q_N
        im = axes[0, 1].imshow(Q_avg[0])
        axes[0, 1].set_title(f"Q {direction_keys[0]} time-avg")
        plt.colorbar(im, ax=axes[0, 1], fraction=0.046)

        # Q_S
        im = axes[0, 2].imshow(Q_avg[1])
        axes[0, 2].set_title(f"Q {direction_keys[1]} time-avg")
        plt.colorbar(im, ax=axes[0, 2], fraction=0.046)

        # Q_E
        im = axes[1, 0].imshow(Q_avg[2])
        axes[1, 0].set_title(f"Q {direction_keys[2]} time-avg")
        plt.colorbar(im, ax=axes[1, 0], fraction=0.046)

        # Q_W
        im = axes[1, 1].imshow(Q_avg[3])
        axes[1, 1].set_title(f"Q {direction_keys[3]} time-avg")
        plt.colorbar(im, ax=axes[1, 1], fraction=0.046)

        # Q_W - Q_E (time-avg)
        diff = Q_avg[3] - Q_avg[2]
        im = axes[1, 2].imshow(diff)
        axes[1, 2].set_title(f"Q {direction_keys[3]} - Q {direction_keys[2]} time-avg")
        plt.colorbar(im, ax=axes[1, 2], fraction=0.046)
    else:
        for ax_idx, key in zip([(0,1),(0,2),(1,0),(1,1),(1,2)], direction_keys + ["W-E"]):
            ax = axes[ax_idx]
            ax.axis("off")
            ax.set_title(f"Q {key} missing")

    for ax in axes.flat:
        ax.set_xticks([])
        ax.set_yticks([])

    fig.savefig(out_path, dpi=dpi)
    plt.close(fig)


# -----------------------------
# Top-level dispatcher
# -----------------------------

def save_field_timeseries(
    r_array,
    K_array,
    densities,
    obs_rows,
    obs_cols,
    obs_time_indices,
    observed_results,
    Q_array=None,
    s_array=None,
    direction_keys=None,
    out_dir="figures/fields",
    prefix="fields",
    dpi=150,
    flipud=False,
    log_eps=1e-12,
    obs_smooth_sigma=None,
    save_Qs_s=True,
    save_timeavg=True,
):
    """
    Modular wrapper that dispatches to helper plotting functions.

    Behavior
    - Saves per-timestep 2x3 figures for r, K, densities, log densities, r>0, observed.
    - Optionally saves per-timestep 1x5 figures for s and Q (4 directions).
    - Optionally saves time-averaged snapshots for both figure types.

    New optional flags
    - save_Qs_s controls whether Q/s figures are produced.
    - save_timeavg controls whether time-averaged snapshots are produced.
    """
    os.makedirs(out_dir, exist_ok=True)

    r_array = np.asarray(r_array)
    K_array = np.asarray(K_array)
    densities = np.asarray(densities)

    obs_rows = np.asarray(obs_rows)
    obs_cols = np.asarray(obs_cols)
    obs_time_indices = np.asarray(obs_time_indices)
    observed_results = np.asarray(observed_results)

    if direction_keys is None:
        direction_keys = ["N", "S", "E", "W"]

    T, Ny, Nx = r_array.shape

    # Validate optional arrays
    if Q_array is not None:
        Q_array = np.asarray(Q_array)
        if Q_array.shape[0] != T:
            raise ValueError("Q_array first dimension must match time T")
        if Q_array.shape[1] != 4:
            raise ValueError("Q_array second dimension must be 4 (directions)")

    if s_array is not None:
        s_array = np.asarray(s_array)
        if s_array.shape[0] != T:
            raise ValueError("s_array first dimension must match time T")

    # Per-timestep loop
    for t in range(T):
        r = r_array[t].copy()
        K = K_array[t].copy()
        D = densities[t].copy()

        if flipud:
            r = np.flipud(r)
            K = np.flipud(K)
            D = np.flipud(D)

        obs_grid = _make_obs_grid_for_t(
            obs_rows, obs_cols, obs_time_indices, observed_results, t, Ny, Nx,
            flipud=flipud, obs_smooth_sigma=obs_smooth_sigma
        )

        fname_main = os.path.join(out_dir, f"{prefix}_t{t:04d}.png")
        _plot_main_timestep(r, K, D, obs_grid, t, fname_main, dpi=dpi)

        if save_Qs_s and ((s_array is not None) or (Q_array is not None)):
            s_t = None if s_array is None else (np.flipud(s_array[t]) if flipud else s_array[t])
            Q_t = None if Q_array is None else (np.flipud(Q_array[t], axis=1) if flipud else Q_array[t])
            fname_qs = os.path.join(out_dir, f"{prefix}_Qs_s_t{t:04d}.png")
            _plot_Qs_s_timestep(s_t, Q_t, direction_keys, t, fname_qs, dpi=dpi)
            if s_array is not None and Q_array is not None:
                fname_reff = os.path.join(out_dir, f"{prefix}_r_eff_t{t:04d}.png")
                _plot_r_eff_timestep(r, s_t, Q_t, direction_keys, t, fname_reff, dpi=dpi)
                fname_mask = os.path.join(out_dir, f"{prefix}_r_eff_mask_t{t:04d}.png")
                _plot_r_eff_masks_timestep(
                    r=r,
                    s=s_t,
                    Qt=Q_t,
                    direction_keys=direction_keys,
                    t=t,
                    out_path=fname_mask,
                    dpi=dpi,
                )

                # r_eff difference maps (vs no dispersal)
                fname_diff = os.path.join(out_dir, f"{prefix}_r_eff_diff_t{t:04d}.png")
                _plot_r_eff_diff_timestep(
                    r=r,
                    s=s_t,
                    Qt=Q_t,
                    direction_keys=direction_keys,
                    t=t,
                    out_path=fname_diff,
                    dpi=dpi,
                )


    # Time-averaged snapshots
    if save_timeavg:
        r_avg = r_array.mean(axis=0)
        K_avg = K_array.mean(axis=0)
        D_avg = densities.mean(axis=0)
        if flipud:
            r_avg = np.flipud(r_avg)
            K_avg = np.flipud(K_avg)
            D_avg = np.flipud(D_avg)

        obs_grid_avg = _make_obs_grid_timeavg(obs_rows, obs_cols, observed_results, Ny, Nx, flipud=flipud)
        fname_avg = os.path.join(out_dir, f"{prefix}_timeavg.png")
        _plot_timeavg_main(r_avg, K_avg, D_avg, obs_grid_avg, fname_avg, dpi=dpi)

        if save_Qs_s and ((s_array is not None) or (Q_array is not None)):
            s_avg = None if s_array is None else (np.flipud(s_array.mean(axis=0)) if flipud else s_array.mean(axis=0))
            Q_avg = None if Q_array is None else (np.flipud(Q_array.mean(axis=0), axis=1) if flipud else Q_array.mean(axis=0))
            fname_qavg = os.path.join(out_dir, f"{prefix}_Qs_s_timeavg.png")
            _plot_timeavg_Qs_s(s_avg, Q_avg, direction_keys, fname_qavg, dpi=dpi)
            if s_array is not None and Q_array is not None:
                fname_reff_avg = os.path.join(out_dir, f"{prefix}_r_eff_timeavg.png")
                _plot_r_eff_timeavg(r_avg, s_avg, Q_avg, direction_keys, fname_reff_avg, dpi=dpi)
                fname_mask_avg = os.path.join(out_dir, f"{prefix}_r_eff_mask_timeavg.png")
                _plot_timeavg_r_eff_masks(
                    r_avg=r_avg,
                    s_avg=s_avg,
                    Q_avg=Q_avg,
                    direction_keys=direction_keys,
                    out_path=fname_mask_avg,
                    dpi=dpi,
                )

                fname_diff_avg = os.path.join(out_dir, f"{prefix}_r_eff_diff_timeavg.png")
                _plot_timeavg_r_eff_diff(
                    r_avg=r_avg,
                    s_avg=s_avg,
                    Q_avg=Q_avg,
                    direction_keys=direction_keys,
                    out_path=fname_diff_avg,
                    dpi=dpi,
                )



# ---------------------------------------------------------------------
# HSGP reconstruction
# ---------------------------------------------------------------------

def rebuild_hsgp(phi, w, alpha_raw, length_raw, ell, m_per_dim, dim):
    """
    Rebuild GP output from HSGP latent weights.
    """
    alpha = jnn.softplus(alpha_raw)
    length = jnn.softplus(length_raw)

    spd = jnp.sqrt(
        diag_spectral_density_squared_exponential(
            alpha=alpha,
            length=length,
            ell=ell,
            m=m_per_dim,
            dim=dim,
        )
    )

    return phi @ (spd * w)


# ---------------------------------------------------------------------
# Growth-field reconstruction
# ---------------------------------------------------------------------

def precompute_r_K(
    time,
    Ny,
    Nx,
    land_rows,
    land_cols,
    r_mean,
    r_bioclim,
    r_pop,
    r_spatial,
    r_temp,
    K_raw_mean,
    logK_bio,
    logK_pop,
):
    """
    Precompute r_array and K_array on the full 2D grid.
    """

    N_land = land_rows.shape[0]

    r_pop = r_pop.reshape(time, N_land)
    logK_pop = logK_pop.reshape(time, N_land)

    r_vals = (
        r_mean
        + r_bioclim[None, :]
        + r_spatial[None, :]
        + r_pop
        + r_temp[:, None]
    )

    K_vals = jnp.exp(
        K_raw_mean
        + logK_bio[None, :]
        + logK_pop
    )

    r_array = jnp.zeros((time, Ny, Nx))
    K_array = jnp.zeros((time, Ny, Nx))

    t_idx = jnp.arange(time)[:, None]

    r_array = r_array.at[t_idx, land_rows, land_cols].set(r_vals)
    K_array = K_array.at[t_idx, land_rows, land_cols].set(K_vals)

    return r_array, K_array


# ---------------------------------------------------------------------
# Forward simulation (imported logic, unchanged)
# ---------------------------------------------------------------------

def allee_factor(pop, allee_scalar, allee_intercept):
    return jnn.sigmoid(pop * allee_scalar + allee_intercept)


def reproduction_safe(N0, r, K, allee_scalar, allee_intercept, eps=1e-12):
    g = jnp.exp(r)
    denom = K + N0 * jnp.expm1(r) + eps
    pop_new = g * N0 * K / denom
    return allee_factor(N0, allee_scalar, allee_intercept) * pop_new


def rightpad(A, Lx, Ly, pad_value=1e-9):
    pad = jnp.ones((Ly, Lx)) * pad_value
    return pad.at[:A.shape[0], :A.shape[1]].set(A)


def rightpad_convolution(pop, kernel):
    Ly, Lx = kernel.shape
    pop_pad = rightpad(pop, Lx, Ly)
    conv = jnp.fft.ifft2(jnp.fft.fft2(pop_pad) * kernel)
    return jnp.real(conv)[:pop.shape[0], :pop.shape[1]]

def juvenile_dispersal_vectorized(
    juvenile_dispersers: jnp.ndarray,       # (Ny, Nx)
    juvenile_fft_kernels: jnp.ndarray,      # (4, Ly, Lx)
    juvenile_edge_corrections: jnp.ndarray, # (4, Ny, Nx)
    Q: jnp.ndarray,                         # (4, Ny, Nx)
    dirichlet_weights: jnp.ndarray = None,
    pad_value: float = 1e-9,
):
    """
    Vectorized juvenile dispersal across four directional kernels with mortality.

    Returns
    -------
    pop_after: (Ny, Nx) array after dispersal and survival
    """
    Ny, Nx = juvenile_dispersers.shape
    Nd = juvenile_fft_kernels.shape[0]  # should be 4

    # ----------------------------
    # Determine directional subpopulations
    # ----------------------------
    if dirichlet_weights is None:
        dirichlet_weights = jnp.ones(Nd) / Nd
    dirichlet_weights = dirichlet_weights.reshape(Nd, 1, 1)  # broadcastable
    dirichlet_weights *= Nd # Quick fix as directional kernels each have 1/Nd mass
    pop_split = juvenile_dispersers[None, :, :] * dirichlet_weights * juvenile_edge_corrections  # (4, Ny, Nx)

    # ----------------------------
    # Pad pop for FFT
    # ----------------------------
    Ly, Lx = juvenile_fft_kernels.shape[1:]
    pop_pad = jnp.pad(pop_split, ((0,0), (0, Ly-Ny), (0, Lx-Nx)), constant_values=pad_value)  # (4, Ly, Lx)

    # ----------------------------
    # FFT-based convolution (all directions at once)
    # ----------------------------
    fft_pop = jnp.fft.fft2(pop_pad, axes=(-2,-1))
    conv = jnp.fft.ifft2(fft_pop * juvenile_fft_kernels, axes=(-2,-1))
    conv_real = jnp.real(conv)[:, :Ny, :Nx]  # crop back to original size

    # ----------------------------
    # Apply Q (survival)
    # ----------------------------
    conv_corrected = conv_real * Q  # all broadcasted

    # ----------------------------
    # Sum over directions
    # ----------------------------
    pop_after = jnp.sum(conv_corrected, axis=0)

    return pop_after

def dispersal_step(pop, K,
                   dispersal_logit_intercept=0.0,
                   dispersal_logit_slope=10.0,
                   target_fraction=0.8,
                   dispersal_intercept=0.0,
                   dispersal_random=None,
                   adult_edge_correction=1.0,
                   juvenile_edge_correction_stack=1.0,
                   adult_fft_kernel=None,
                   juvenile_fft_kernel_stack=None,
                   Q_array=None,
                   eps=1e-6,
                   clip_z=30.0,
                   min_p=1e-8):
    """
    Full dispersal step with numerical stability, juvenile/adult split, and convolution update.
    
    Parameters
    ----------
    pop : array
        Current population at all grid cells.
    K : array
        Carrying capacity at all grid cells.
    dispersal_logit_intercept : float
        Baseline logit for total dispersal probability.
    dispersal_logit_slope : float
        Steepness of total dispersal probability vs relative density.
    target_fraction : float
        Fraction of K where dispersal probability ~0.5.
    dispersal_intercept : float
        Baseline juvenile dispersal probability (logit) modifier.
    dispersal_random : array
        Random temporal variation for juvenile dispersal (same shape as pop).
    adult_edge_correction : float or array
        Edge correction multiplier for adults.
    juvenile_edge_correction : float or array
        Edge correction multiplier for juveniles.
    adult_fft_kernel : array
        Convolution kernel for adult dispersal.
    juvenile_fft_kernel : array
        Convolution kernel for juvenile dispersal.
    eps : float
        Small number added to K to avoid division by zero.
    clip_z : float
        Maximum absolute value of sigmoid input for stability.
    min_p : float
        Minimum/maximum probability to avoid exact 0 or 1.
    
    Returns
    -------
    pop_new : array
        Updated population after dispersal step.
    dispersers : array
        Total number of dispersers (for diagnostics if needed).
    """
    # -----------------------------
    # Total dispersal probability
    # -----------------------------
    K_safe = K + eps
    z_total = dispersal_logit_intercept + dispersal_logit_slope * (pop / K_safe - target_fraction)
    z_total = jnp.clip(z_total, -clip_z, clip_z)
    p_total = jnn.sigmoid(z_total)
    p_total = jnp.clip(p_total, min_p, 1 - min_p)
    
    dispersers = p_total * pop

    # -----------------------------
    # Juvenile vs adult split
    # -----------------------------
    if dispersal_random is None:
        dispersal_random = jnp.zeros_like(pop)
        
    z_juvenile = dispersal_intercept + dispersal_random
    z_juvenile = jnp.clip(z_juvenile, -clip_z, clip_z)
    p_juvenile = jnn.sigmoid(z_juvenile)
    p_juvenile = jnp.clip(p_juvenile, min_p, 1 - min_p)

    juvenile_dispersers = dispersers * p_juvenile
    adult_dispersers = dispersers - juvenile_dispersers

    # -----------------------------
    # Convolution for dispersal movement
    # -----------------------------
    adult_update = rightpad_convolution(adult_dispersers * adult_edge_correction, adult_fft_kernel)
    # juvenile_update = rightpad_convolution(juvenile_dispersers * juvenile_edge_correction, juvenile_fft_kernel)

    juvenile_update = juvenile_dispersal_vectorized(
        juvenile_dispersers=juvenile_dispersers,
        juvenile_fft_kernels = juvenile_fft_kernel_stack, 
        juvenile_edge_corrections=juvenile_edge_correction_stack,
        Q=Q_array,
    )
    pop_update = adult_update + juvenile_update - dispersers

    # -----------------------------
    # Update population
    # -----------------------------
    pop_new = pop + pop_update

    return pop_new




# ---------------------------------------------------------------------
# Full reconstruction pipeline
# ---------------------------------------------------------------------

def reconstruct_fields(params, data):
    """
    Main reconstruction entry point.
    """

    # ---- Bioclim GP ----
    f_bio_1 = rebuild_hsgp(
        data["phi_bioclim"],
        params["f1_bio/beta"],
        params["alpha_bio_raw"],
        params["length_bio_raw"],
        data["ell_bioclim"],
        data["m_bioclim"],
        data["d_bioclim"],
    )

    f_bio_2 = rebuild_hsgp(
        data["phi_bioclim"],
        params["f2_bio/beta"],
        params["alpha_bio_raw"],
        params["length_bio_raw"],
        data["ell_bioclim"],
        data["m_bioclim"],
        data["d_bioclim"],
    )

    r_bio, logK_bio = params["L_bio"] @ jnp.stack([f_bio_1, f_bio_2])

    # ---- Human population GP ----
    f_pop = rebuild_hsgp(
        data["phi_pop"],
        params["pop/beta"],
        params["pop/alpha_pop_raw"],
        params["pop/length_pop_raw"],
        data["ell_pop"],
        data["m_pop"],
        dim=1,
    )

    r_pop = params["pop/b_r"] * f_pop
    logK_pop = params["pop/b_K"] * f_pop

    # ---- Scalars ----
    allee_slope = jnn.softplus(params["allee_slope_raw"])
    allee_scalar = data["pop_scalar"] * allee_slope

    inv_pop = jnn.softplus(params["inv_eta"]) # not scalar anymore?
    # inv_pop = 100

    # ---- r, K fields ----
    r_array, K_array = precompute_r_K(
        time=data["time"],
        Ny=data["Ny"],
        Nx=data["Nx"],
        land_rows=data["land_rows"],
        land_cols=data["land_cols"],
        r_mean=params["r_mean"],
        r_bioclim=r_bio,
        r_pop=r_pop,
        r_spatial=params["r_spatial"],
        r_temp=params["r_temp"],
        K_raw_mean=params["K_raw_mean"],
        logK_bio=logK_bio,
        logK_pop=logK_pop,
    )

    s_array, Q_array = precompute_s_Q_vectorized(
        r_array,
        data['juvenile_fft_kernel_stack'],      # (4, Ny, Nx), directions first
        jnn.softplus(params["dispersal_survival_slope_raw"]),               # slope for survival of dispersing juveniles
        params["dispersal_survival_threshold"]            # threshold for survival of dispersing juveniles
    )

    # ---- Forward simulation ----
    densities = forward_sim_2d(
        time=data["time"],
        initial_pop=data['initpop_latent'],
        r_array=r_array,
        K_array=K_array,
        dispersal_logit_intercept=params["dispersal_logit_intercept"],
        dispersal_logit_slope=params["dispersal_logit_slope"],
        dispersal_intercept=params["dispersal_intercept"],
        dispersal_random=params["dispersal_random"],
        adult_fft_kernel=data['adult_fft_kernel'],
        juvenile_fft_kernel_stack=data['juvenile_fft_kernel_stack'],
        adult_edge_correction=data['adult_edge_correction'],
        juvenile_edge_correction_stack=data['juvenile_edge_correction_stack'],
        Q_array=Q_array,
        land_mask=data['land_mask'],
        inv_pop=inv_pop,
        inv_location=data['inv_location'],
        inv_timestep = data['inv_timestep'],
        allee_scalar=allee_scalar,
        allee_intercept=params["allee_intercept"],
        pseudo_zero=data['pseudo_zero']
    )

    return r_array, K_array, s_array, Q_array, densities


# ---------------------------------------------------------------------
# I/O wiring (EDIT THESE PATHS)
# ---------------------------------------------------------------------


def main(
    map_path="map_estimate_4.npz",
    data_path="data/stan_data_for_python.npz",
    output_path="reconstructed_fields_5.npz",
    checkpoint_path="/home/breallis/dev/range_limits_pymc/checkpoints/map_ckpt_step29000.pkl",  # if provided, use checkpoint instead of map_path
):
    # -----------------------------
    # Rebuild data exactly as in MAP
    # -----------------------------
    data = build_data_jax(data_path)

    # -----------------------------
    # Load parameters (checkpoint or map)
    # -----------------------------
    if checkpoint_path:
        print(f"Loading checkpoint params from: {checkpoint_path}")
        params = load_checkpoint_params(checkpoint_path, data)
    else:
        print(f"Loading MAP params from: {map_path}")
        params = load_map_params(map_path)

    # -----------------------------
    # Reconstruct fields
    # -----------------------------
    r_array, K_array, s_array, Q_array, densities = reconstruct_fields(params, data)

    # -----------------------------
    # Save outputs
    # -----------------------------
    np.savez(
        output_path,
        r_array=np.asarray(r_array),
        K_array=np.asarray(K_array),
        densities=np.asarray(densities),
    )

    save_field_timeseries(
        r_array,
        K_array,
        densities,
        obs_rows=data["obs_rows"],
        obs_cols=data["obs_cols"],
        obs_time_indices=data["obs_time_indices"],
        observed_results=data["observed_results"],
        s_array=s_array,
        Q_array=Q_array,
        out_dir="figures/fields8",
        prefix="figs",
        obs_smooth_sigma=1.0,
    )

    print("all done")


if __name__ == "__main__":
    main()
